设计模式
代理模式：为另一个对象提供一个替身或占位符以控制对这个对象的访问。
使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以使远程的对象（远程代理）、创建开销大的对象（虚拟代理），或需要安全控制的对象（保护代理）。

远程代理：可以作为另一个JVM上对象的本地代表。调用代理的方法，会被代理利用网络转发到远程执行，并且结果会通过网络返回给代理，再由代理将结果返回给客户。
虚拟代理：作为创建开销大的对象的代表。虚拟代理经常直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。对象创建后代理就会将请求直接委托给对象。
动态代理：java在java.lang.reflect包中有自己的代理支持，利用这个包你可以在运行时动态的创建一个代理类，实现一个或多个接口，并将方法的调用转发到你所指定的类。实际的代理类是在运行时创建的，在Java中我们称这种技术为动态代理。利用Java的动态代理，可以实现保护代理。
防火墙代理：控制网络资源的访问，保护主题免于“坏客户”的侵害。
智能引用代理：当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数。
缓存代理：为开销大的运算结果提供暂时存储，它也运行多个客户共享结果，以减少计算或网络延迟。
同步代理：多线程的情况下为主题提供安全的访问。
复杂隐藏代理：用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有时候也成为外观代理。复杂隐藏代理和外观模式不一样，因为代理控制访问，而外观模式只是提供另一组接口。
写入时复制代理：用来控制对象的复制，方法是延迟对象的复制，知道客户真正需要为止，这是虚拟代理的变体。

制作远程服务
（1）制作远程接口
（2）制作远程实现
（3）利用rmic产生stub和skeleton
（4）启动RMI registry
（5）开始远程服务

设计原则
封装变化
多用组合，少用继承
针对接口编程，不针对实现编程
为交互对象之间的送耦合设计而努力
类应该对扩展开发，对修改关闭
依赖抽象，而不依赖具体类
只和朋友交谈
别找我，我会找你
类应该只有一个改变的理由

要点
代理在结构上类似装饰者，但是目的不一样。装饰者模式为对象加上行为，而代理则是控制行为。
和其他包装者一样，代理会造成你的设计中类的数目增加。